<!DOCTYPE html>
<html>
<head>
    <title>Architectural Patterns</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href="../assets/css/reset.css" rel="stylesheet" type="text/css" />
    <link href="../assets/css/fonts.css" rel="stylesheet" type="text/css" />
    <link href="../assets/css/typography.css" rel="stylesheet" type="text/css" />
    <link href="../assets/css/style.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
      .remark-inline-code{
        font-size: 18px;
        color: #333;
        background: #f8f8f8;
      }
    </style>
</head>
<body>
    
<div class="wrapper">
    <header class="mainheader">
        <div class="logo">
            <div class="divider"><a href="../index.html"><img src="../assets/img/Logo.png"></a></div>
            <a href="../mvc/index.html#1"><span class="logotext">Architectural Patterns</span></a>
        </div>
    </header>
</div>
<!-- ================== Slides ================== -->
<textarea id="source">


class: center, middle

.title[
Front-end training
# Architectural Patterns
]

---

# Architectural Patterns
It is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Architectural patterns are similar to software design pattern but have a broader scope.

---

class: center, middle
# Why?

---

# Web 1.0 (1990s)
- Static pages (no dynamic content)
- Server-side rendering
- Main browsers: Netscape & IE

---

class: center, middle
![web1](assets/img/web1.png)

---

# Web 2.0 (2000s)
- Dynamic HTML (JS/CSS to manipulate DOM)
- Examples: (Amazon, Wikipedia, Youtube, Gmail)
- Ajax, jQuery

---

class: center, middle
![web1](assets/img/web2.png)

---

# Web 3.0 ? (2010s)
- ECMAScript 5
- Client-side rendering / Single-page application (SPA)
- MVC frameworks: AngularJS, BackboneJS

---

class: center, middle
![gneo](assets/img/spagetti.jpg)

---

class: center, middle
![gneo](assets/img/professor.jpg)

---

# Separated Presentation
The idea behind Separated Presentation is to make a clear division between domain objects that model our perception of the real world, and presentation objects that are the GUI elements we see on the screen.

---

class: center, middle

.title[
# MVC
]

---

# MVC

.img-wrap-70[![MVC](assets/img/mvc.png)]

--

- Model–View–Controller (MVC) is a software architectural pattern for implementing user interfaces.

--

- It divides a given software application into three interconnected parts, so as to separate internal representations of information from the ways that information is presented to or accepted from the user.

--

- Since 1979 (Trygve Reenskaug, Jim Althoff)

--

- Frontend framework example: [Backbone.js](http://backbonejs.org/)

---

# Model

Model is where the application’s data objects are stored.

--

- Doesn’t know anything about views and controllers.

--

- Notifies its associated views and controllers when there has been a change in its state.

--

- May have additional features: conversions, validations, computed properties, access control.

---

# Model (code example)

```javascript
class PhotoModel {
    constructor ({name, date, url}) {
        this.name = name;
        this.date = date;
        this.url = url;
    }
    
    get caption() {
        return `${ this.name } - ${ this.url }`;
    }
    
    validation() {
        // validation here
    }
}
    
const photoModelInstance = new PhotoModel({
    name: 'myPhoto',
    date: 'today',
    url: 'http://example.com/mPhoto.jpg'
});
```

---

# View

View requests information from the model that it needs for generating an output representation to the user. Knows how the user interface looks.

--

- Doesn’t care how to get the data or where the data comes from.

--

- May use the existing HTML or may build new HTML

--

- Listens to user interaction

---

# View (code example)

```javascript
class PhotoView {
    constructor(photoModelInstance, photoController) {
        this.photoModelInstance = photoModelInstance;
        // On model update re-render view
        photoModelInstance.addSubscriber(this.render); 
        // Controller will handle user interaction
        this.addEventListener('click',  () => {
            photoController.handleEvent('click',  this.photoModelInstance);
        });
    }
  
    get htmlTemplate() {
        const { url, caption } = this.photoModelInstance;
        return `<img src="${ url }" alt="${ caption }" />`;
    }
  
    render() {} // / render view

    addEventListener(ev, cb) {}// add event listener
}
```

---

# Controller

Takes in user commands, and mades decision on model updates.

--

- Updates the model when user interacts with the view

--

- Knows and keeps the business logic

---

# Controller (code example)

```javascript
class PhotoController {
    constructor() {
        this.photoModelInstance = new PhotoModel({
            name: 'myPhoto',
            date: 'today',
            url: 'http://example.com/mPhoto.jpg'
        });

        this.photoViewInstance = new photoView(this.photoModelInstance, this);
    }

    handleEvent() {} // handle event
}
```

---

# What does MVC give us?
This separation of concerns in MVC facilitates simpler modularization of an application's functionality and enables:

--

- Easier overall maintenance. When updates need to be made to the application it is very clear whether the changes are data-centric, meaning changes to models and possibly controllers, or merely visual, meaning changes to views.

--

- Decoupling models and views means that it is significantly more straight-forward to write unit tests for business logic

--

- Duplication of low-level model and controller code (i.e what we may have been using instead) is eliminated across the application

--

- Depending on the size of the application and separation of roles, this modularity allows developers responsible for core logic and developers working on the user-interfaces to work simultaneously

---

class: center, middle

.title[
  # MVP
]

---

# MVP

.img-wrap-70[![MVP](assets/img/mvp.png)]

--

- Model-view-presenter (MVP) is a derivative of the MVC design pattern which focuses on improving presentation logic.

--

- Presenter is a component which contains the user-interface business logic for the view

--

- Since 1990 (Taligent)

--

- Frontend framework example: [Riot](https://riot.js.org)

---

# Presenter

--

- 2 way communication with the view

--

- View Communication: The view communicates with the presenter by directly calling functions on an instance of the presenter.  The presenter communicates with the view by talking to an interface implemented by the view.

--

- There is a single presenter for each view

--

- Passive View

---

# Benefits:

--

- it increases the testability of our application

--

- it provides a more clean separation between the view and the model

---

class: center, middle
.title[
 # MVVM
]

---

# MVVM

.img-wrap-70[![MVVM](assets/img/mvvm.png)]

--

- MVVM (Model View ViewModel) is an architectural pattern based on MVC and MVP, which attempts to more clearly separate the development of user-interfaces (UI) from that of the business logic and behaviour in an application.

--

- Two-way Data binding

--

- Since 2005 (Silverlight)

--

- Frontend framework example: [AngularJS](https://angularjs.org/)

---

# ViewModel

--

- 2 way communication with the view

--

- The ViewModel represents the view.  This means that fields in a view model usually match up more closely with the view than with the model.

--

- View Communication: view binds directly to the ViewModel.  Because of the binding, changes in the view are automatically reflected in the ViewModel and changes in the ViewModel are automatically reflected in the view.

--

- There is a single ViewModel for each view

---

# MVC vs MVP vs MVVM

## MVC

In MVC, the View sits on top of our architecture with the controller beside it. Models sit below the controller and so our Views know about our controllers and controllers know about Models. Here, our Views have direct access to Models. Exposing the complete Model to the View however may have security and performance costs, depending on the complexity of our application.

## MVP

In MVP, the role of the controller is replaced with a Presenter. Presenters sit at the same level as views, listening to events from both the View and model and mediating the actions between them. Unlike MVVM, there isn’t a mechanism for binding Views to ViewModels, so we instead rely on each View implementing an interface allowing the Presenter to interact with the View.

## MVVM

MVVM consequently allows us to create View-specific subsets of a Model which can contain state and logic information, avoiding the need to expose the entire Model to a View. Unlike MVP’s Presenter, a ViewModel is not required to reference a View. The View can bind to properties on the ViewModel which in turn expose data contained in Models to the View. As we’ve mentioned, the abstraction of the View means there is less logic required in the code behind it.

---

class: center, middle
.title[
 # Flux
]

---

# Flux

.img-wrap-70[![Flux](assets/img/flux.png)]

--

- Flux is a pattern for managing data flow in your application. The most important concept is that data flows in one direction.

--

- Unidirectional flow. Every change goes through the dispatcher

--

- Since 2014 (Facebook)

--

- Frontend framework example: [Redux](https://redux.js.org/) + [Reat](https://reactjs.org/)(for View)

---

# Dispatcher

The dispatcher receives actions and dispatches them to stores that have registered with the dispatcher. Every store will receive every action. There should be only one singleton dispatcher in each application.

--

## Example:

1. User types in title for a todo and hits enter.

--

2. The view captures this event and dispatches an "add-todo" action containing the title of the todo.

--

3. Every store will then receive this action.


---

# Store

A store is what holds the data of an application. Stores will register with the application's dispatcher so that they can receive actions. The data in a store must only be mutated by responding to an action. There should not be any public setters on a store, only getters. Stores decide what actions they want to respond to. Every time a store's data changes it must emit a "change" event. There should be many stores in each application.

--

## Example:

1. Store receives an "add-todo" action..

--

2. It decides it is relevant and adds the todo to the list of things that need to be done today.

--

3. The store updates its data and then emits a "change" event.

---

# Actions

Actions define the internal API of your application. They capture the ways in which anything might interact with your application. They are simple objects that have a "type" field and some data.

--

## Example:

1. When a user clicks "delete" on a completed todo a single "delete-todo" action is dispatched:

```javascript
{
    type: 'delete-todo',
    todoID: '1234',
}
```

---

# View

Data from stores is displayed in views. When a view uses data from a store it must also subscribe to change events from that store. Then when the store emits a change the view can get the new data and re-render. Actions are typically dispatched from views as the user interacts with parts of the application's interface.

--

## Example:

1. The main view subscribes to the TodoStore.

--

2. It accesses a list of the Todos and renders them in a readable format for the user to interact with.

--

3. When a user types in the title of a new Todo and hits enter the view tells the Dispatcher to dispatch an action.

--

4. All stores receive the dispatched action.

--

5. The TodoStore handles the action and adds another Todo to its internal data structure, then emits a "change" event.

--

6. The main view is listening for the "change" event. It gets the event, gets new data from the TodoStore, and then re-renders the list of Todos in the user interface.

---


# Related resources
- [Classic MVC on vanilla js](https://medium.com/@patrickackerman/classic-front-end-mvc-with-vanilla-javascript-7eee550bc702)
- [Todo app example on different frameworks](http://todomvc.com/)
- [Flux](https://facebook.github.io/flux/)
- [Reflux](https://github.com/reflux/refluxjs)
- [Redux](https://redux.js.org/)



    </textarea>
<!-- ================== End of Slides ================== -->

    <script src="../assets/js/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">remark.create({highlightStyle: 'github'});</script>
</body>
</html>
